/*----------------------------------------------------------------------------*/
/* Copyright: CEA
 * contributors: F. Ledoux and N. Le Goff (2015)
 *
 * franck.ledoux@cea.fr
 * nicolas.le-goff@cea.fr
 *
 * The GMDS library is a computer program whose purpose is to provide a set of
 * functionnalities to represent and handle any type of meshes (2D, 3D,
 * triangles, tetrahedra, quad, hexa, polygons, polyhedra, etc.) and write
 * meshing algorithms. So it gathers many mathematical objects like points,
 * segment, quaternions, etc. and basic algorithms useful to build more evolved
 * ones.
 *
 * This software is governed by the CeCILL-C license under French law and
 * abiding by the rules of distribution of free software.  You can  use,
 * modify and/ or redistribute the software under the terms of the CeCILL-C
 * license as circulated by CEA, CNRS and INRIA at the following URL
 * "http://www.cecill.info".
 *
 * As a counterpart to the access to the source code and  rights to copy,
 * modify and redistribute granted by the license, users are provided only
 * with a limited warranty  and the software's author,  the holder of the
 * economic rights,  and the successive licensors  have only  limited
 * liability.
 *
 * In this respect, the user's attention is drawn to the risks associated
 * with loading,  using,  modifying and/or developing or reproducing the
 * software by the user in light of its specific status of free software,
 * that may mean  that it is complicated to manipulate,  and  that  also
 * therefore means  that it is reserved for developers  and  experienced
 * professionals having in-depth computer knowledge. Users are therefore
 * encouraged to load and test the software's suitability as regards their
 * requirements in conditions enabling the security of their systems and/or
 * data to be ensured and,  more generally, to use and operate it in the
 * same conditions as regards security.
 *
 * The fact that you are presently reading this means that you have had
 * knowledge of the CeCILL-C license and that you accept its terms.
 */
/*----------------------------------------------------------------------------*/
/** \file    VTKWriter.tpp
 *  \author  F. LEDOUX
 *  \date    02/24/2009
 */
/*----------------------------------------------------------------------------*/
#ifndef GMDS_VTKWRITER_H_
#define GMDS_VTKWRITER_H_
/*----------------------------------------------------------------------------*/
// headers of STL files
#include <iostream>
#include <fstream>
#include <sstream>
#include <map>
/*----------------------------------------------------------------------------*/
// headers of GMDS files
#include <GMDS/IG/IG.h>
#include <GMDS/Math/Quaternion.h>
#include <GMDS/Math/Cross.h>
#include <GMDS/Math/Cross2D.h>
/*----------------------------------------------------------------------------*/
namespace gmds{
    /*----------------------------------------------------------------------------*/
#include <GMDS/IO/VTKWriter_def.h>
    
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    VTKWriter<TMesh>::VTKWriter(TMesh& AMesh)
    :mesh_(AMesh)
    {
        
        MeshModel model = mesh_.getModel();
        if (model.getDim() == 2)
            mesh_dimension_ = 2;
        else if (model.getDim() == 3)
            mesh_dimension_ = 3;
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    VTKWriter<TMesh>::~VTKWriter()
    {
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::
    write(const std::string& AFileName, const int& AMask)
    {
        
        if ((AMask | F) == AMask)
            writeFaces(AFileName);
        
        if ((AMask | R) == AMask)
            writeRegions(AFileName);
        
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::
    writeFaces(const std::string& AFileName)
    {
        
        std::stringstream file_name;
        file_name << AFileName << "_FACES.vtk";
        std::ofstream output(file_name.str(), std::ios::out);
        if (!output)
            throw GMDSException("Impossible to create a VTK File (Legacy format)");
        
        output << "# vtk DataFile Version 3.0\n";
        output << "Generated by GMDS VTK Writer\n\n";
        output << "ASCII\n";
        output << "DATASET UNSTRUCTURED_GRID\n";
        
        writeNodes(output);
        
        writeCellFaces(output);
        
        writeNodesData(output);
        writeFacesData(output);
        output.close();
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeRegions(const std::string& AFileName)
    {
        
        std::stringstream file_name;
        file_name << AFileName << "_CELLS.vtk";
        std::ofstream output(file_name.str(), std::ios::out);
        if (!output)
            throw GMDSException("Impossible to create a VTK File (Legacy format)");
        
        output << "# vtk DataFile Version 3.0\n";
        output << "Generated by GMDS VTK Writer\n\n";
        output << "ASCII\n";
        output << "DATASET UNSTRUCTURED_GRID\n";
        
        writeNodes(output);
        
        writeCellRegions(output);
        
        writeNodesData(output);
        writeRegionsData(output);
        output.close();
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeNodes(std::ofstream& AOut)
    {
        AOut << "POINTS " << mesh_.getNbNodes() << " float\n";
        typename TMesh::node_iterator it_nodes = mesh_.nodes_begin();
        
        int vtk_node_id = 0;
        if (mesh_dimension_ == 3){
            for (; !it_nodes.isDone(); it_nodes.next()) {
                Node n = it_nodes.value();
                if(n.getID()==InfinityID){
                    AOut <<"0 0 0\n";
                }
                else{
                    AOut << n.X() << " " << n.Y() << " " << n.Z() << "\n";
                }
                nodes_connection_[n.getID()] = vtk_node_id++;
            }
        }
        else {
            for (; !it_nodes.isDone(); it_nodes.next()) {
                Node n = it_nodes.value();
                if(n.getID()==InfinityID){
                    AOut <<"0 0 0\n";
                }
                else{
                    AOut << n.X() << " " << n.Y() << " 0\n";
                }
                nodes_connection_[n.getID()] = vtk_node_id++;
            }
        }
        
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeCellFaces(std::ofstream& AOut)
    {
        AOut << "CELLS ";
        int nb_cells = mesh_.getNbFaces();
        AOut << nb_cells << " ";
        
        int vtk_cell_size = 0;
        
        typename TMesh::face_iterator it_faces = mesh_.faces_begin();
        
        
        for (; !it_faces.isDone(); it_faces.next())
        {
            Face f = it_faces.value();
            vtk_cell_size += 1 + f.getNbNodes();
        }
        AOut << vtk_cell_size << "\n";
        
        int vtk_face_id = 0;
        it_faces = mesh_.faces_begin();
        
        for (; !it_faces.isDone(); it_faces.next())
        {
            Face f = it_faces.value();
            std::vector<Node> nodes = f.get<Node>();
            AOut << nodes.size() << " ";
            for (unsigned int i_n = 0; i_n < nodes.size(); i_n++){
                AOut << nodes_connection_[nodes[i_n].getID()] << " ";
            }
            AOut << "\n";
            faces_connection_[f.getID()] = vtk_face_id++;
        }
        AOut << "CELL_TYPES " << nb_cells << "\n";
        it_faces = mesh_.faces_begin();
        
        for (; !it_faces.isDone(); it_faces.next())
        {
            Face f = it_faces.value();
            if (f.getType() == GMDS_TRIANGLE)
                AOut << "5 \n";
            else if (f.getType() == GMDS_QUAD)
                AOut << "9 \n";
            else {
                AOut << "7 \n";
            }
        }
        
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeCellRegions(std::ofstream& AOut)
    {
        AOut << "CELLS ";
        int nb_cells = mesh_.getNbRegions();
        AOut << nb_cells << " ";
        
        int vtk_cell_size = 0;
        
        typename TMesh::region_iterator it_regions = mesh_.regions_begin();
        
        for (; !it_regions.isDone(); it_regions.next()){
            Region r = it_regions.value();
            vtk_cell_size += 1 + r.getNbNodes();
        }
        AOut << vtk_cell_size << "\n";
        
        
        int vtk_region_id = 0;
        it_regions = mesh_.regions_begin();
        
        for (; !it_regions.isDone(); it_regions.next()) {
            Region r = it_regions.value();
            std::vector<Node> nodes = r.get<Node>();
            AOut << nodes.size() << " ";
            for (unsigned int i_n = 0; i_n < nodes.size(); i_n++)
            {
                AOut << nodes_connection_[nodes[i_n].getID()] << " ";
            }
            AOut << "\n";
            regions_connection_[r.getID()] = vtk_region_id++;
        }
        AOut << "CELL_TYPES " << nb_cells << "\n";
        it_regions = mesh_.regions_begin();
        for (; !it_regions.isDone(); it_regions.next()) {
            Region r = it_regions.value();
            if (r.getType() == GMDS_TETRA)
                AOut << "10 \n";
            else if (r.getType() == GMDS_HEX)
                AOut << "12 \n";
            else if (r.getType() == GMDS_PRISM3)
                AOut << "13 \n";
            else if (r.getType() == GMDS_PYRAMID)
                AOut << "14 \n";
            else
                throw GMDSException("VTKWriter::writeCellRegions cell type not handled.");
        }
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeNodesData(std::ofstream& AOut)
    {
        AOut << "POINT_DATA " << mesh_.getNbNodes() << "\n";
        
        typename TMesh::node_iterator it_nodes = mesh_.nodes_begin();
        
        /* FIRST WE PUT THE GMDS IDS*/
        AOut << "SCALARS GMDS_ID int 1\n";
        AOut << "LOOKUP_TABLE default\n";
        
        for (; !it_nodes.isDone(); it_nodes.next()){
            Node n = it_nodes.value();
            AOut << n.getID() << "\n";
        }
        /* now we create data array for recognizing clouds*/
        
        /* points data structure is now ready to store mesh nodes */
        TCellID maxID = mesh_.getMaxLocalID(0);
        std::vector<bool> nodes_in_cloud;
        nodes_in_cloud.resize(maxID*2);
        
        for (unsigned int cloud_index = 0;
             cloud_index < mesh_.getNbClouds(); cloud_index++){
            
            typename TMesh::cloud& cl = mesh_.getCloud(cloud_index);
            
            for (unsigned int i = 0; i < maxID*2; i++)
                nodes_in_cloud[i] = 0;
            
            if (cl.size()) {
                std::vector<Node> nodes_in_cl = cl.cells();
                for (unsigned int n_index = 0; n_index < nodes_in_cl.size(); n_index++)
                    nodes_in_cloud[nodes_in_cl[n_index].getID()] = 1;
                AOut << "SCALARS " << cl.name().c_str() << " int 1\n";
                AOut << "LOOKUP_TABLE default\n";
                
                typename TMesh::node_iterator it;
                for (it = mesh_.nodes_begin(); !it.isDone(); it.next())
                    AOut << nodes_in_cloud[it.value().getID()] << "\n";
            }
        }
        
        std::vector<VariableItf*> node_variables = mesh_.getAllVariables(GMDS_NODE);
        for (int i = 0; i < node_variables.size(); i++)
        {
            VariableItf* current_var = node_variables[i];
            switch (current_var->getType()){
                case(VariableItf::var_int) :
                {
                    Variable<int>* v_int = dynamic_cast<Variable<int>*> (current_var);
                    
                    AOut << "SCALARS " << v_int->getName().c_str() << " int 1\n";
                    AOut << "LOOKUP_TABLE default\n";
                    
                    typename TMesh::node_iterator it;
                    for (it = mesh_.nodes_begin(); !it.isDone(); it.next())
                        AOut << (*v_int)[it.value().getID()] << "\n";
                }
                    break;
                case(VariableItf::var_double) :
                {
                    Variable<double>* v_double = dynamic_cast<Variable<double>*> (current_var);
                    AOut << "SCALARS " << v_double->getName().c_str() << " float 1\n";
                    AOut << "LOOKUP_TABLE default\n";
                    
                    typename TMesh::node_iterator it;
                    for (it = mesh_.nodes_begin(); !it.isDone(); it.next()){
                        AOut << (*v_double)[it.value().getID()] << "\n";
                    }
                }
                    break;
                case(VariableItf::var_double_vec) :
                {
                    Variable<math::Vector>* var_double_vec3D =
                    dynamic_cast<Variable<math::Vector>*> (current_var);
                    AOut << "VECTORS " << var_double_vec3D->getName().c_str() << " float \n";
                    
                    
                    typename TMesh::node_iterator it;
                    
                    for (it = mesh_.nodes_begin(); !it.isDone(); it.next())
                    {
                        double* tuple = new double[3];
                        tuple[0] = (*var_double_vec3D)[it.value().getID()].X();
                        tuple[1] = (*var_double_vec3D)[it.value().getID()].Y();
                        tuple[2] = (*var_double_vec3D)[it.value().getID()].Z();
                        AOut << tuple[0] << " " << tuple[1] << " " << tuple[2] << "\n";
                    }
                }
                    break;
                    
                case(VariableItf::var_cross_2D) :
                {
                    Variable<math::Cross2D>* var_cross =
                    dynamic_cast<Variable<math::Cross2D>*> (current_var);
                    
                    std::vector<math::Vector> vx, vy, vx_inv, vy_inv;
                    typename TMesh::node_iterator it;
                    for (it = mesh_.nodes_begin(); !it.isDone(); it.next())
                    {
                        math::Cross2D c((*var_cross)[it.value().getID()]);
                        std::vector<math::Vector> vecs = c.componentVectors();
                        vx.push_back(vecs[0]);
                        vy.push_back(vecs[1]);
                        vx_inv.push_back(vecs[2]);
                        vy_inv.push_back(vecs[3]);
                        
                    }
                    
                    AOut << "VECTORS " << var_cross->getName().c_str() << "_X float \n";
                    writeVectorSection(AOut, vx);
                    AOut << "VECTORS " << var_cross->getName().c_str() << "_Y float \n";
                    writeVectorSection(AOut, vy);
                    AOut << "VECTORS " << var_cross->getName().c_str() << "_XI float \n";
                    writeVectorSection(AOut, vx_inv);
                    AOut << "VECTORS " << var_cross->getName().c_str() << "_YI float \n";
                    writeVectorSection(AOut, vy_inv);
                }
                    break;
                case(VariableItf::var_quaternion) :
                {
                    Variable<math::Quaternion>* var_quat =
                    dynamic_cast<Variable<math::Quaternion>*> (current_var);
                    
                    std::vector<math::Vector> vx, vy, vz, vx_inv, vy_inv, vz_inv;
                    typename TMesh::node_iterator it;
                    for (it = mesh_.nodes_begin(); !it.isDone(); it.next())
                    {
                        math::Chart t((*var_quat)[it.value().getID()]);
                        vx.push_back(t.X());
                        vy.push_back(t.Y());
                        vz.push_back(t.Z());
                        vx_inv.push_back(t.X().opp());
                        vy_inv.push_back(t.Y().opp());
                        vz_inv.push_back(t.Z().opp());
                    }
                    
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_X float \n";
                    writeVectorSection(AOut, vx);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_Y float \n";
                    writeVectorSection(AOut, vy);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_Z float \n";
                    writeVectorSection(AOut, vz);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_XI float \n";
                    writeVectorSection(AOut, vx_inv);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_YI float \n";
                    writeVectorSection(AOut, vy_inv);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_ZI float \n";
                    writeVectorSection(AOut, vz_inv);
                    
                }
                    break;
                default:
                    break;
            }
        }
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeFacesData(std::ofstream& AOut)
    {
        AOut << "CELL_DATA " << mesh_.getNbFaces() << "\n";
        
        typename TMesh::face_iterator it = mesh_.faces_begin();
        
        /* FIRST WE PUT THE GMDS IDS*/
        AOut << "SCALARS GMDS_ID int 1\n";
        AOut << "LOOKUP_TABLE default\n";
        
        for (; !it.isDone(); it.next())
        {
            Face f = it.value();
            AOut << f.getID() << "\n";
        }
        
        /* now we create data array for recognizing surfaces*/
        
        /* points data structure is now ready to store mesh nodes */
        TCellID maxID = mesh_.getMaxLocalID(2);
        std::vector<bool> faces_in_surf;
        faces_in_surf.resize(maxID + 1);
        
        for (unsigned int surf_index = 0; surf_index < mesh_.getNbSurfaces(); surf_index++)
        {
            
            typename TMesh::surface& s = mesh_.getSurface(surf_index);
            
            for (unsigned int i = 0; i < maxID + 1; i++)
                faces_in_surf[i] = 0;
            
            if (s.size())
            {
                std::vector<Face> faces_in_s = s.cells();
                for (unsigned int f_index = 0; f_index < faces_in_s.size(); f_index++)
                    faces_in_surf[faces_in_s[f_index].getID()] = 1;
                AOut << "SCALARS " << s.name().c_str() << " int 1\n";
                AOut << "LOOKUP_TABLE default\n";
                
                typename TMesh::face_iterator it;
                for (it = mesh_.faces_begin(); !it.isDone(); it.next())
                    AOut << faces_in_surf[it.value().getID()] << "\n";
            }
        }
        
        std::vector<VariableItf*> face_variables = mesh_.getAllVariables(GMDS_FACE);
        for (int i = 0; i < face_variables.size(); i++)
        {
            VariableItf* current_var = face_variables[i];
            switch (current_var->getType()){
                case(VariableItf::var_int) :
                {
                    Variable<int>* v_int = dynamic_cast<Variable<int>*> (current_var);
                    
                    AOut << "SCALARS " << v_int->getName().c_str() << " int 1\n";
                    AOut << "LOOKUP_TABLE default\n";
                    
                    typename TMesh::face_iterator it;
                    for (it = mesh_.faces_begin(); !it.isDone(); it.next()){
                        AOut << (*v_int)[it.value().getID()] << "\n";
                    }
                }
                    break;
                case(VariableItf::var_double) :
                {
                    Variable<double>* v_double = dynamic_cast<Variable<double>*> (current_var);
                    AOut << "SCALARS " << v_double->getName().c_str() << " float 1\n";
                    AOut << "LOOKUP_TABLE default\n";
                    
                    typename TMesh::face_iterator it;
                    for (it = mesh_.faces_begin(); !it.isDone(); it.next())
                        AOut << (*v_double)[it.value().getID()] << "\n";
                    
                }
                    break;
                case(VariableItf::var_double_vec) :
                {
                    Variable<math::Vector>* var_double_vec3D =
                    dynamic_cast<Variable<math::Vector>*> (current_var);
                    AOut << "VECTORS " << var_double_vec3D->getName().c_str() << " float \n";

                    
                    typename TMesh::face_iterator it;
                    for (it = mesh_.faces_begin(); !it.isDone(); it.next())
                    {
                        double* tuple = new double[3];
                        tuple[0] = (*var_double_vec3D)[it.value().getID()].X();
                        tuple[1] = (*var_double_vec3D)[it.value().getID()].Y();
                        tuple[2] = (*var_double_vec3D)[it.value().getID()].Z();
                        AOut << tuple[0] << " " << tuple[1] << " " << tuple[2] << "\n";
                    }
                }
                    break;
                case(VariableItf::var_cross_2D) :
                {
                    Variable<math::Cross2D>* var_cross =
                    dynamic_cast<Variable<math::Cross2D>*> (current_var);
                    
                    std::vector<math::Vector> vx, vy, vx_inv, vy_inv;
                    typename TMesh::face_iterator it;
                    for (it = mesh_.faces_begin(); !it.isDone(); it.next())
                    {
                        math::Cross2D c((*var_cross)[it.value().getID()]);
                        std::vector<math::Vector> vecs = c.componentVectors();
                        vx.push_back(vecs[0]);
                        vy.push_back(vecs[1]);
                        vx_inv.push_back(vecs[2]);
                        vy_inv.push_back(vecs[3]);
                        
                    }
                    
                    AOut << "VECTORS " << var_cross->getName().c_str() << "_X float \n";
                    writeVectorSection(AOut, vx);
                    AOut << "VECTORS " << var_cross->getName().c_str() << "_Y float \n";
                    writeVectorSection(AOut, vy);
                    AOut << "VECTORS " << var_cross->getName().c_str() << "_XI float \n";
                    writeVectorSection(AOut, vx_inv);
                    AOut << "VECTORS " << var_cross->getName().c_str() << "_YI float \n";
                    writeVectorSection(AOut, vy_inv);
                }
                    break;
                case(VariableItf::var_quaternion) :
                {
                    Variable<math::Quaternion>* var_quat =
                    dynamic_cast<Variable<math::Quaternion>*> (current_var);
                    
                    std::vector<math::Vector> vx, vy, vz, vx_inv, vy_inv, vz_inv;
                    typename TMesh::face_iterator it;
                    for (it = mesh_.faces_begin(); !it.isDone(); it.next())
                    {
                        math::Chart t((*var_quat)[it.value().getID()]);
                        vx.push_back(t.X());
                        vy.push_back(t.Y());
                        vz.push_back(t.Z());
                        vx_inv.push_back(t.X().opp());
                        vy_inv.push_back(t.Y().opp());
                        vz_inv.push_back(t.Z().opp());
                    }
                    
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_X float \n";
                    writeVectorSection(AOut, vx);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_Y float \n";
                    writeVectorSection(AOut, vy);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_Z float \n";
                    writeVectorSection(AOut, vz);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_XI float \n";
                    writeVectorSection(AOut, vx_inv);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_YI float \n";
                    writeVectorSection(AOut, vy_inv);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_ZI float \n";
                    writeVectorSection(AOut, vz_inv);
                    
                }
                    break;
                    
                default:
                    break;
            }
        }
    }
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeRegionsData(std::ofstream& AOut)
    {
        AOut << "CELL_DATA " << mesh_.getNbRegions() << "\n";
        
        typename TMesh::region_iterator it = mesh_.regions_begin();
        
        /* FIRST WE PUT THE GMDS IDS*/
        AOut << "SCALARS GMDS_ID int 1\n";
        AOut << "LOOKUP_TABLE default\n";
        for (; !it.isDone(); it.next())
        {
            Region r = it.value();
            AOut << r.getID() << "\n";
        }
        
        /* now we create data array for recognizing volumes*/
        
        /* region data structure is now ready to store mesh nodes */
        /*     TCellID maxID = mesh_.getMaxLocalID(3);
         std::vector<bool> regions_in_vol;
         regions_in_vol.reserve(maxID + 10);
         
         for (unsigned int volume_index = 0; volume_index < mesh_.getNbVolumes(); volume_index++)
         {
         
         typename TMesh::volume& r = mesh_.getVolume(volume_index);
         
         for (unsigned int i = 0; i < maxID + 1; i++)
         regions_in_vol[i] = 0;
         
         if (r.size())
         {
         std::vector<Region> regions_in_r = r.cells();
         for (unsigned int r_index = 0; r_index < regions_in_r.size(); r_index++)
         regions_in_vol[regions_in_r[r_index].getID()] = 1;
         AOut << "SCALARS " << r.name().c_str() << " int 1\n";
         AOut << "LOOKUP_TABLE default\n";
         
         typename TMesh::region_iterator it;
         for (it = mesh_.regions_begin(); !it.isDone(); it.next())
         AOut << regions_in_vol[it.value().getID()] << "\n";
         }
         }*/
        
        std::vector<VariableItf*> region_variables = mesh_.getAllVariables(GMDS_REGION);
        for (unsigned int i = 0; i < region_variables.size(); i++)
        {
            VariableItf* current_var = region_variables[i];
            switch (current_var->getType()){
                case(VariableItf::var_int) :
                {
                    Variable<int>* v_int = dynamic_cast<Variable<int>*> (current_var);
                    
                    AOut << "SCALARS " << v_int->getName().c_str() << " int 1\n";
                    AOut << "LOOKUP_TABLE default\n";
                    
                    typename TMesh::region_iterator it;
                    for (it = mesh_.regions_begin(); !it.isDone(); it.next()){
                        AOut << (*v_int)[it.value().getID()] << "\n";
                    }
                }
                    break;
                case(VariableItf::var_double) :
                {
                    Variable<double>* v_double = dynamic_cast<Variable<double>*> (current_var);
                    AOut << "SCALARS " << v_double->getName().c_str() << " float 1\n";
                    AOut << "LOOKUP_TABLE default\n";
                    
                    typename TMesh::region_iterator it;
                    for (it = mesh_.regions_begin(); !it.isDone(); it.next())
                    {
                        AOut << (*v_double)[it.value().getID()] << "\n";
                    }
                }
                    break;
                case(VariableItf::var_double_vec) :
                {
                    Variable<math::Vector>* var_double_vec3D =
                    dynamic_cast<Variable<math::Vector>*> (current_var);
                    AOut << "VECTORS " << var_double_vec3D->getName().c_str() << " float \n";
                    
                    
                    typename TMesh::region_iterator it;
                    for (it = mesh_.regions_begin(); !it.isDone(); it.next())
                        
                    {
                        double* tuple = new double[3];
                        tuple[0] = (*var_double_vec3D)[it.value().getID()].X();
                        tuple[1] = (*var_double_vec3D)[it.value().getID()].Y();
                        tuple[2] = (*var_double_vec3D)[it.value().getID()].Z();
                        AOut << tuple[0] << " " << tuple[1] << " " << tuple[2] << "\n";
                    }
                }
                    break;
                case(VariableItf::var_cross_2D) :
                {
                    Variable<math::Cross2D>* var_cross =
                    dynamic_cast<Variable<math::Cross2D>*> (current_var);
                    
                    std::vector<math::Vector> vx, vy, vx_inv, vy_inv;
                    typename TMesh::region_iterator it;
                    for (it = mesh_.regions_begin(); !it.isDone(); it.next())
                    {
                        math::Cross2D c((*var_cross)[it.value().getID()]);
                        std::vector<math::Vector> vecs = c.componentVectors();
                        vx.push_back(vecs[0]);
                        vy.push_back(vecs[1]);
                        vx_inv.push_back(vecs[2]);
                        vy_inv.push_back(vecs[3]);
                        
                    }
                    
                    AOut << "VECTORS " << var_cross->getName().c_str() << "_X float \n";
                    writeVectorSection(AOut, vx);
                    AOut << "VECTORS " << var_cross->getName().c_str() << "_Y float \n";
                    writeVectorSection(AOut, vy);
                    AOut << "VECTORS " << var_cross->getName().c_str() << "_XI float \n";
                    writeVectorSection(AOut, vx_inv);
                    AOut << "VECTORS " << var_cross->getName().c_str() << "_YI float \n";
                    writeVectorSection(AOut, vy_inv);
                }
                    break;
                case(VariableItf::var_quaternion) :
                {
                    Variable<math::Quaternion>* var_quat =
                    dynamic_cast<Variable<math::Quaternion>*> (current_var);
                    
                    std::vector<math::Vector> vx, vy, vz, vx_inv, vy_inv, vz_inv;
                    typename TMesh::region_iterator it;
                    for (it = mesh_.regions_begin(); !it.isDone(); it.next())
                    {
                        math::Chart t((*var_quat)[it.value().getID()]);
                        vx.push_back(t.X());
                        vy.push_back(t.Y());
                        vz.push_back(t.Z());
                        vx_inv.push_back(t.X().opp());
                        vy_inv.push_back(t.Y().opp());
                        vz_inv.push_back(t.Z().opp());
                    }
                    
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_X float \n";
                    writeVectorSection(AOut, vx);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_Y float \n";
                    writeVectorSection(AOut, vy);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_Z float \n";
                    writeVectorSection(AOut, vz);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_XI float \n";
                    writeVectorSection(AOut, vx_inv);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_YI float \n";
                    writeVectorSection(AOut, vy_inv);
                    AOut << "VECTORS " << var_quat->getName().c_str() << "_ZI float \n";
                    writeVectorSection(AOut, vz_inv);
                    
                }
                    break;
                    
                default:
                    break;
            }
        }
        
    }
    
    /*----------------------------------------------------------------------------*/
    template<typename TMesh>
    void VTKWriter<TMesh>::writeVectorSection(
                                              std::ofstream& AOut,
                                              const std::vector<math::Vector>& AV)
    {
        for (unsigned int i = 0; i < AV.size() ; i++) 
        {
            math::Vector v = AV[i];
            AOut << v.X() << " " << v.Y() << " " << v.Z() << "\n";
        }
        
    }
  /*----------------------------------------------------------------------------*/
}
/*----------------------------------------------------------------------------*/
#endif /* GMDS_VTKWRITER_H_ */
/*----------------------------------------------------------------------------*/
